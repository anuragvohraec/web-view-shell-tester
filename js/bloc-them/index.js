import{render as t,html as e,nothing as s}from"/js/lit-html/lit-html.js";import{unsafeHTML as i}from"/js/lit-html/directives/unsafe-html.js";class o{get name(){return this._name}get hostElement(){return this._hostElement}set hostElement(t){this._hostElement=t}}class n extends HTMLElement{constructor(){super(),this.attachShadow({mode:"open"});let t=this.getAttribute("use");this._useAttr=n.parseUseAttribute(t)}get useAttribute(){return this._useAttr}static parseUseAttribute(t){if(t){let e={},s=t.split(";");for(let t of s){let s=t.split(":");2===s.length&&(e[s[0].trim()]=s[1].trim())}return e}}}class l extends n{constructor(t,e){super();const s=this.getAttribute("bloc");if(!(t=s||t))throw`[BLOC-THEM] : No bloc name provided for: ${this.tagName}`;if(this.nameOfBlocToSearch=t,this._blocBuilderConfig=e||{},this._blocBuilderConfig.buildWhen||(this._blocBuilderConfig.buildWhen=l.stateChangeBuildWhenFunction),this._blocBuilderConfig.blocs_map)for(let t of Object.keys(this._blocBuilderConfig.blocs_map))t===this.nameOfBlocToSearch&&(this._bloc=this._blocBuilderConfig.blocs_map[t])}get blocName(){return this.nameOfBlocToSearch}static stateChangeBuildWhenFunction(t,e){return e!==t}get blocBuilderConfig(){return this._blocBuilderConfig}set blocBuilderConfig(t){t.buildWhen&&(this._blocBuilderConfig.buildWhen=t.buildWhen),t.otherSearchCriteria&&(this._blocBuilderConfig.otherSearchCriteria=t.otherSearchCriteria),t.blocs_map&&(this._blocBuilderConfig.blocs_map||(this._blocBuilderConfig.blocs_map={}),this._blocBuilderConfig.blocs_map={...this._blocBuilderConfig.blocs_map,...t.blocs_map},t.blocs_map[this.nameOfBlocToSearch]&&(this._bloc=this._blocBuilderConfig.blocs_map[this.nameOfBlocToSearch],this._build(this._bloc.state)))}get bloc(){return this._bloc}get state(){var t;return null===(t=this.bloc)||void 0===t?void 0:t.state}connectedCallback(){var t;if(this._initialize(),null===(t=this._blocBuilderConfig)||void 0===t?void 0:t.blocs_map)for(let t in this._blocBuilderConfig.blocs_map){const e=this._blocBuilderConfig.blocs_map[t];Promise.resolve().then((()=>{e.onConnection(this)}))}}getBloc(t){return c.search(t,this)}_initialize(){if(this._bloc||(this._bloc=c.search(this.nameOfBlocToSearch,this,this._blocBuilderConfig.otherSearchCriteria)),!this._bloc)throw`[BLOC-THEM] : ${this.tagName} depends upon bloc ${this.nameOfBlocToSearch} , but is not found in the DOM tree`;{this._prevState=this._bloc.state;const t=e=>{try{this._blocBuilderConfig.buildWhen(this._prevState,e)&&(this._build(e),this._prevState=e)}catch(e){console.error(`${t._ln_name} listener function has caught an error. Which mostly happens when your builder function is throwing error, which is not what should be done/happen!`),console.error(e)}};t._ln_name=this.tagName,this.id&&(t._ln_name+=`#${this.id}`),this._subscriptionId=this._bloc._subscribe(t),this._build(this._prevState)}}disconnectedCallback(){var t,e;if(null===(t=this._blocBuilderConfig)||void 0===t?void 0:t.blocs_map)for(let t in this._blocBuilderConfig.blocs_map)this._blocBuilderConfig.blocs_map[t].onDisconnection();null===(e=this._bloc)||void 0===e||e._unsubscribe(this._subscriptionId)}getRootElement(){return this.shadowRoot}_build(e){let s=this.builder(e);t(s,this.getRootElement())}}class r extends n{constructor(t){super(),this.config=t,this.found_blocs={},this.subscribed_states={},this.listener_ids={}}get blocsMap(){return this.config.blocs_map}getBloc(t){let e=this.blocsMap[t];return e||(e=this.found_blocs[t],e||(e=c.search(t,this))),e}connectedCallback(){if(this.isConnected){for(let t of this.config.subscribed_blocs){let e=a.search(t,this);if(!e)throw`[BLOC-THEM] : ${this.tagName} depends upon bloc ${t} , but is not found in the DOM tree`;this.found_blocs[t]=e}for(let t in this.found_blocs){this.subscribed_states[t]=this.found_blocs[t].state;let e=e=>{this.subscribed_states={...this.subscribed_states},this.subscribed_states[t]=e,this._build()};e._ln_name=this.tagName,this.listener_ids[t]=this.found_blocs[t]._subscribe(e)}if(this._build(),this.config.blocs_map)for(let t in this.config.blocs_map){let e=this.config.blocs_map[t];Promise.resolve().then((()=>{e.onConnection(this)}))}}}disconnectedCallback(){if(this.config.blocs_map)for(let t in this.config.blocs_map)this.config.blocs_map[t].onDisconnection();for(let t in this.found_blocs)try{this.found_blocs[t]._unsubscribe(this.listener_ids[t])}finally{continue}}build_when(t,e){return t!==e}getRootElement(){return this.shadowRoot}_build(){let e=this.convertSubscribedStatesToReactiveState(this.subscribed_states);if(this.build_when(this.state,e)){this.state=e;let s=this.build(this.state);t(s,this.getRootElement())}}}class c extends n{constructor(t={}){super(),this._blocsMap=t;for(let t of Object.keys(this._blocsMap)){this._blocsMap[t].hostElement=this}Object.freeze(this._blocsMap)}get blocsMap(){return this._blocsMap}connectedCallback(){if(this._build(),this._blocsMap)for(let t in this._blocsMap)Promise.resolve().then((()=>this._blocsMap[t].onConnection(this)))}disconnectedCallback(){if(this._blocsMap)for(let t in this.blocsMap)this.blocsMap[t].onDisconnection()}static search(t,e,s=(t=>!0)){var i,o;let n=e;for(;n;){if(s(n))if(n instanceof c){let e=n.blocsMap[t];if(e)return e}else if(n instanceof l){if(n.blocName===t&&n.bloc)return n.bloc;if(null===(o=null===(i=n.blocBuilderConfig)||void 0===i?void 0:i.blocs_map)||void 0===o?void 0:o[t])return n.blocBuilderConfig.blocs_map[t]}else if(n instanceof r){let e=n.blocsMap[t];if(e)return e}let e=n.parentNode;e instanceof ShadowRoot&&(e=e.host),n=e}}getRootElement(){return this.shadowRoot}_build(){let e=this.builder();t(e,this.getRootElement())}}function h(t){return Object.keys(t).forEach((e=>{"object"!=typeof t[e]||Object.isFrozen(t[e])||h(t[e])})),Object.freeze(t)}class a extends o{constructor(t,e=[]){super(),this.initState=t,this.listenToBlocs=e,this._listener_id_ref=1,this._listeners={},this._blocsMap={},this.foundListenedBlocs={},this._state=t}get blocsMap(){return this._blocsMap}static search(t,e,s=(t=>!0)){return c.search(t,e,s)}onConnection(t){this.hostElement=t;for(let e of this.listenToBlocs){let s=a.search(e,this.hostElement);if(!s)throw this.foundListenedBlocs={},`[BLOC-THEM] : ${this._name.toUpperCase()} hosted on ${t.tagName} depends upon ${e} bloc, which is not found the parent DOMs!`;let i=t=>{this.reactToStateChangeFrom(e,t)};i._ln_name=e,this.foundListenedBlocs[e]={bloc:s,subscriber_id:s._subscribe(i)}}}onDisconnection(){for(let t of Object.keys(this.foundListenedBlocs))try{this.foundListenedBlocs[t].bloc._unsubscribe(this.foundListenedBlocs[t].subscriber_id)}catch(t){console.error(t)}this.hostElement=void 0}reactToStateChangeFrom(t,e){}getBloc(t){var e;let s=this._blocsMap[t];if(!s&&(s=null===(e=this.foundListenedBlocs[t])||void 0===e?void 0:e.bloc,!s&&(s=c.search(t,this.hostElement),!s)))throw`[BLOC-THEM] : <${this.name}> bloc requires bloc: ${t}! to function, but is not present in the reverse DOM hierarchy!`;return s}get state(){return this._state}emit(t){var e;this._state=t;for(let s of Object.keys(this._listeners))try{this._listeners[`${s}`]&&this._listeners[`${s}`](t)}catch(t){console.log(`[BLOC-THEM] : Listener ${null===(e=this._listeners[s])||void 0===e?void 0:e._ln_name} do not have try catch bloc. It throws error which is not caught in its pure function.`),console.error(t)}}_subscribe(t){let e=`${this._listener_id_ref}`;return this._listeners[e]=t,this._listener_id_ref++,e}_unsubscribe(t){t&&this._listeners[t]&&delete this._listeners[t]}}class b{static make(t){let s=this.define(t);return e`${i(`<${s}></${s}>`)}`}static tag_name_from_config(t){return`${t.tag_prefix?t.tag_prefix+"-"+t.tag_name:t.tag_name}`}static define(t){class e extends l{constructor(){super(t.bloc_name,{blocs_map:t.blocs_map,buildWhen:t.buildWhen})}builder(e){return t.builder_function(e)}}let s=this.tag_name_from_config(t);return customElements.get(s)||customElements.define(s,e),s}}class u extends a{constructor(t){super(null!=t?t:s)}}customElements.define("bt-apex",class extends l{get prop(){return this._prop}set prop(t){var e;this._prop=t,t&&(null===(e=this.bloc)||void 0===e||e.notifyAttributeChange(t))}builder(t){return t}});export{u as ApexBloc,n as BaseBlocsHTMLElement,a as Bloc,l as BlocBuilder,c as BlocsProvider,b as GuiMaker,o as HasNameAndHost,r as MultiBlocsReactiveWidget,h as deepFreeze};
